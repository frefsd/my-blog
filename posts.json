[{
		"title": "欢迎来到我的博客",
		"date": "2025年10月26日",
		"category": "随笔",
		"excerpt": "这是我的第一篇文章，记录我从零开始搭建个人博客的过程，以及为什么每个程序员都应该拥有一个自己的表达空间。",
		"content": "<h2>引言：为什么我要写博客？</h2><p>大家好，我是咸鱼梦想家。今天是我正式开启博客之旅的第一天。你可能会问：现在都 2025 年了，谁还写博客？不是有知乎、微博、小红书吗？</p><p>是的，这些平台很方便，但它们属于「别人的花园」。你在上面种的花，随时可能被平台修剪、封禁，甚至消失。而博客，是我自己的「数字花园」——我可以自由表达，不受算法支配，不被流量绑架。</p><p>写博客不是为了立刻涨粉，而是为了记录成长。每一篇文章，都是我思考的痕迹，是未来回望时的路标。</p><h2>我是如何用 JavaScript 搭建这个博客的？</h2><p>这个博客完全由 HTML、CSS 和 JavaScript 驱动，没有使用 WordPress 或任何 CMS。它的核心逻辑非常简单：</p><ul><li>首页从 <code>posts.json</code> 加载文章列表</li><li>通过 <code>fetch()</code> 获取数据</li><li>用 JavaScript 动态渲染到页面</li><li>支持搜索和分类筛选</li><li>点击文章跳转到 <code>post.html?id=0</code> 查看详情</li></ul><p>虽然现在功能还很基础，但它已经是一个「可运行的产品」。未来我会逐步添加：评论系统、标签云、暗黑模式、RSS 订阅等功能。</p><p>最让我兴奋的是，这个博客不需要服务器端语言（如 PHP/Node.js），可以直接部署在 GitHub Pages 上，永久免费。</p><h2>技术栈选择：为什么是纯前端？</h2><p>很多人会问：为什么不直接用 Hexo、VuePress 或 Next.js？</p><p>我的答案是：我想从「零」开始理解整个流程。就像学做饭，先学会煮鸡蛋，再学炒菜。</p><p>使用原生 JavaScript 让我更清楚地理解：</p><ol><li>DOM 操作是如何影响性能的</li><li>如何优雅地处理异步加载</li><li>前端路由的基本原理（通过 URL 参数）</li><li>如何组织可维护的代码结构</li></ol><p>这种「造轮子」的过程，比直接用框架学到的更多。当然，未来我也会尝试现代化框架，但这段原生开发的经历，会成为我宝贵的底层认知。</p><h2>写博客的三个好处</h2><p>经过这几天的实践，我深刻体会到写博客的三大好处：</p><h3>1. 提升表达能力</h3><p>把脑子里模糊的想法，变成清晰的文字，本身就是一种思维训练。你必须逻辑严谨、语言准确，才能让别人看懂。</p><h3>2. 建立个人品牌</h3><p>在互联网上，「存在感」就是影响力。持续输出内容，会让别人记住你。也许未来某天，HR 或合作方会因为看到你的博客而联系你。</p><h3>3. 倒逼学习</h3><p>为了写一篇关于「响应式设计」的文章，我不得不重新学习 Flexbox 和媒体查询。写作是最好的学习方式，因为它要求你「真正理解」，而不是「大概懂了」。</p><h2>未来的更新计划</h2><p>接下来，我计划每周更新 1~2 篇文章，主题包括：</p><ul><li>前端开发技巧（HTML/CSS/JS）</li><li>工具推荐（VS Code 插件、Markdown 编辑器）</li><li>学习方法论</li><li>程序员的日常思考</li></ul><p>如果你也想搭建自己的博客，欢迎关注我，我会持续分享从 0 到 1 的全过程。你不需要是技术大牛，只要愿意动手，就能做出属于自己的网站。</p><h2>结语：开始即胜利</h2><p>很多人都想写博客，但一直「准备中」。他们总觉得自己还没准备好：技术不够好、文笔不够好、想法不够深刻。</p><p>但我想说：**开始，就是最大的胜利**。第一篇文章不需要完美，只需要真实。就像我这篇，语法可能不优雅，逻辑可能不严密，但它是我成长的起点。</p><p>感谢你读到这里。如果你喜欢这个博客，欢迎收藏、分享，或者在评论区留下你的想法。我们下一篇文章见！</p>"
	},
	{
		"title": "JavaScript 是如何改变网页的？",
		"date": "2025年10月25日",
		"category": "技术",
		"excerpt": "从静态页面到动态应用，JavaScript 是如何通过 DOM 操作、事件监听和异步加载重塑网页体验的？",
		"content": "<h2>网页的进化史：从静态到动态</h2><p>在 JavaScript 出现之前，网页只是「电子文档」。你打开一个页面，看到的就是服务器返回的 HTML，无法交互，无法更新内容，就像一本不会动的电子书。</p><p>1995 年，Netscape 公司推出了 JavaScript，它被设计为一种「轻量级脚本语言」，可以直接在浏览器中运行。从此，网页开始「活」了起来。</p><h2>DOM：JavaScript 操控网页的桥梁</h2><p>DOM（Document Object Model）是 JavaScript 能够操作网页的核心。它把 HTML 文档转换成一个「对象树」，每个标签都是一个节点，JavaScript 可以增删改查这些节点。</p><p>例如：</p><pre><code>document.getElementById('title').innerText = '内容被改变了！';</code></pre><p>这行代码会在页面加载后，自动修改 ID 为 <code>title</code> 的元素文本。用户无需刷新页面，就能看到新内容——这就是「动态」的本质。</p><h2>事件驱动：让网页响应用户操作</h2><p>JavaScript 可以监听用户的操作，如点击、滚动、输入等，并做出响应。</p><p>示例：</p><pre><code>document.getElementById('btn').addEventListener('click', function() {<br>  alert('按钮被点击了！');<br>});</code></pre><p>这种「事件驱动」的编程模型，让网页具备了应用的特性，不再是单向的信息传递。</p><h2>AJAX 与 Fetch：无需刷新的数据加载</h2><p>过去，要获取新数据必须刷新页面。AJAX（Asynchronous JavaScript and XML）技术改变了这一点。</p><p>现代的 <code>fetch()</code> API 让我们可以：</p><ul><li>从服务器请求数据</li><li>在不刷新页面的情况下更新内容</li><li>实现无限滚动、实时搜索等功能</li></ul><p>这也是你能在我们博客首页看到「搜索文章」功能的原因——所有文章数据都在 <code>posts.json</code> 中，通过 <code>fetch</code> 加载，无需跳转。</p><h2>单页应用（SPA）的兴起</h2><p>JavaScript 的能力催生了单页应用（如 React、Vue 项目）。整个网站只有一个 HTML 页面，所有内容通过 JS 动态加载和切换，体验接近原生 App。</p><p>虽然我们的博客还是多页应用，但已经具备了 SPA 的某些特性，比如数据驱动视图。</p><h2>结语：JavaScript 是现代 Web 的基石</h2><p>没有 JavaScript，就没有今天的富交互网页。它让浏览器从「文档阅读器」变成了「应用运行平台」。学习 JavaScript，就是学习如何构建现代互联网的底层逻辑。</p>"
	},
	{
		"title": "响应式设计：让网站适配所有设备",
		"date": "2025年10月24日",
		"category": "前端",
		"excerpt": "从手机到桌面，如何使用 CSS 媒体查询、Flexbox 和视口设置让网站在任何设备上都能优雅显示？",
		"content": "<h2>为什么响应式设计如此重要？</h2><p>2025 年，超过 60% 的网页浏览发生在手机上。如果你的网站在手机上显示错乱、文字太小、按钮点不到，90% 的用户会直接关闭页面。</p><p>响应式设计（Responsive Design）就是让同一个网站，在不同尺寸的屏幕上都能提供良好体验的技术。</p><h2>三大核心技术</h2><h3>1. 视口（Viewport）设置</h3><p>必须在 <code>&lt;head&gt;</code> 中添加：</p><pre><code>&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;</code></pre><p>它告诉手机浏览器：「不要缩放，按实际宽度显示」。</p><h3>2. 弹性布局：Flexbox</h3><p>使用 <code>display: flex</code> 让元素自动排列，适应容器大小。</p><p>示例：</p><pre><code>.container {<br>  display: flex;<br>  flex-wrap: wrap;<br>}</code></pre><p>当屏幕变窄时，子元素会自动换行。</p><h3>3. 媒体查询（Media Queries）</h3><p>根据屏幕宽度应用不同样式：</p><pre><code>@media (max-width: 768px) {<br>  .post-item {<br>    margin-bottom: 1rem;<br>  }<br>}</code></pre><p>我们博客的移动端适配就是靠它实现的。</p><h2>移动优先设计原则</h2><p>现代开发提倡「移动优先」：先设计手机端样式，再逐步增强桌面端体验。这样能保证核心内容在小屏幕上依然可用。</p><h2>测试响应式的工具</h2><p>在 Chrome 开发者工具中，按下 <code>F12</code> → 切换设备图标 → 可模拟手机、平板等设备。</p><p>建议测试至少三种尺寸：320px（小手机）、768px（平板）、1200px（桌面）。</p><h2>常见误区</h2><ul><li>只在桌面设计，最后才适配手机（成本高）</li><li>使用固定宽度（如 <code>width: 800px</code>）</li><li>忽略触摸操作（按钮太小）</li></ul><h2>结语：响应式是标配，不是加分项</h2><p>在今天，一个不响应式的网站，就像一家只接待高个子顾客的商店。无论你的设计多美，功能多强，如果用户打不开、看不清，一切归零。响应式设计，是每个前端开发者的基本功。</p>"
	},
	{
		"title": "Java 基础：为什么它是程序员的“第一课”？",
		"date": "2025年10月23日",
		"category": "Java",
		"excerpt": "从 HelloWorld 到面向对象，Java 不仅是一门语言，更是一种编程思维的启蒙。它为何能成为无数开发者的起点？",
		"content": "<h2>从 HelloWorld 开始的旅程</h2><p>还记得你第一次写代码时的激动吗？对很多人来说，那行 <code>System.out.println(\"Hello, World!\");</code> 就是编程世界的入口。</p><p>而这个入口，常常就是 Java。</p><h2>Java 的三大特性：为什么适合初学者？</h2><h3>1. 跨平台：一次编写，到处运行</h3><p>Java 程序运行在 JVM（Java 虚拟机）上，而不是直接运行在操作系统上。这意味着你写的代码，可以在 Windows、Mac、Linux 上无缝运行——只要装了 JVM。</p><p>这种「跨平台性」让 Java 成为企业级开发的首选。</p><h3>2. 强类型：减少低级错误</h3><p>Java 要求你明确声明变量类型：<code>int age = 25;</code>、<code>String name = \"Tom\";</code>。虽然写起来比 Python 多几个字，但它能在编译阶段就发现很多错误，避免运行时崩溃。</p><h3>3. 面向对象（OOP）：培养结构化思维</h3><p>Java 是典型的面向对象语言。它教会我们用「类」和「对象」来建模现实世界。</p><p>比如，我们可以定义一个 <code>Student</code> 类：</p><pre><code>public class Student {<br>    private String name;<br>    private int age;<br><br>    public void study() {<br>        System.out.println(name + \" 正在学习\");<br>    }<br>}</code></pre><p>然后创建多个学生对象：<code>new Student()</code>。这种思维方式，是构建大型系统的基础。</p><h2>Java 的核心概念速览</h2><ul><li><strong>类与对象</strong>：模板与实例</li><li><strong>封装</strong>：用 <code>private</code> 保护数据</li><li><strong>继承</strong>：子类复用父类功能</li><li><strong>多态</strong>：同一方法，不同行为</li><li><strong>异常处理</strong>：用 <code>try-catch</code> 应对错误</li><li><strong>集合框架</strong>：List、Map、Set 的使用</li></ul><h2>Java 的应用场景</h2><p>别以为 Java 过时了！它依然是：</p><ul><li>安卓 App 开发的底层语言（Kotlin 也在 JVM 上）</li><li>银行、电商等大型系统的后端主力</li><li>大数据生态（Hadoop、Spark）的核心支持语言</li></ul><h2>学习建议：不要死记语法</h2><p>很多初学者卡在「记不住语法」上。其实，Java 的关键是理解思想，而不是背代码。</p><p>建议：</p><ol><li>动手写 10 个小程序（计算器、学生管理系统等）</li><li>画类图理解对象关系</li><li>使用 IntelliJ IDEA 提高效率</li></ol><h2>结语：Java 是一座桥</h2><p>它可能不是最潮的语言，但它是一座坚实的桥，连接着编程的过去与未来。掌握 Java，不只是学会一门语言，更是理解「如何构建可靠系统」的第一步。无论你未来走向 Python、Go 还是 C++，这段经历都会成为你的底层能力。</p>"
	},
	{
		"title": "SSM 框架整合：从零搭建一个 Web 后端",
		"date": "2025年10月22日",
		"category": "Java",
		"excerpt": "Spring + Spring MVC + MyBatis 如何协同工作？手把手教你整合 SSM，打造一个可运行的 Java Web 应用。",
		"content": "<h2>什么是 SSM？</h2><p>SSM 是三个 Java 框架的缩写：</p><ul><li><strong>Spring</strong>：负责管理对象（IoC）和解耦</li><li><strong>Spring MVC</strong>：处理 HTTP 请求，实现前后端交互</li><li><strong>MyBatis</strong>：操作数据库，替代原始 JDBC</li></ul><p>它们组合起来，就是一套成熟的 Java Web 开发方案。</p><h2>为什么还要学 SSM？Spring Boot 不是更火吗？</h2><p>是的，Spring Boot 更现代化，但 SSM 是它的「前身」。理解 SSM，就像理解汽车发动机原理——即使你开的是电动车，也知道轮子是怎么转的。</p><h2>SSM 的工作流程</h2><p>用户发起一个请求，比如访问 <code>/user/list</code>，流程如下：</p><ol><li><strong>Spring MVC</strong> 接收到请求，找到对应的 Controller</li><li>Controller 调用 <strong>Service</strong> 层处理业务逻辑</li><li>Service 调用 <strong>Mapper</strong> 接口查询数据库</li><li>MyBatis 执行 SQL，返回结果</li><li>Controller 将数据返回给前端（JSON 或页面）</li></ol><p>整个过程由 <strong>Spring</strong> 容器统一管理对象的创建和依赖注入。</p><h2>配置文件是关键</h2><p>SSM 需要多个配置文件：</p><ul><li><code>spring-context.xml</code>：Spring 核心配置</li><li><code>spring-mvc.xml</code>：MVC 路由和视图解析</li><li><code>mybatis-config.xml</code>：MyBatis 设置</li><li><code>db.properties</code>：数据库连接信息</li></ul><p>虽然繁琐，但正是这些配置让你看清了「请求是如何流转的」。</p><h2>整合步骤简述</h2><ol><li>导入 Maven 依赖（Spring、MyBatis、MySQL 驱动等）</li><li>配置 web.xml，注册 DispatcherServlet 和 ContextLoaderListener</li><li>编写实体类、Mapper 接口、Service、Controller</li><li>使用注解（@Controller、@Service、@Autowired）简化开发</li><li>部署到 Tomcat 测试</li></ol><h2>SSM 的优缺点</h2><p><strong>优点</strong>：</p><ul><li>结构清晰，适合教学</li><li>灵活，可定制性强</li><li>企业老项目仍广泛使用</li></ul><p><strong>缺点</strong>：</p><ul><li>配置繁琐</li><li>启动慢</li><li>不如 Spring Boot 自动化</li></ul><h2>结语：学 SSM 是为了超越 SSM</h2><p>掌握 SSM 不是为了停留在过去，而是为了更好地理解 Spring Boot 的「自动配置」到底做了什么。当你知道底层原理，使用高级框架时才能游刃有余，而不是「只会复制粘贴」。</p>"
	},
	{
		"title": "MyBatis-Plus：让数据库操作像呼吸一样简单",
		"date": "2025年10月21日",
		"category": "数据库",
		"excerpt": "还在写重复的 CRUD SQL？MyBatis-Plus 让你一行代码完成增删改查，还能自动生成代码，提升开发效率 80%。",
		"content": "<h2>MyBatis 的痛点：CRUD 太啰嗦</h2><p>你有没有写过这样的代码？</p><pre><code>// 查询所有用户<br>List<User> users = userMapper.selectAll();<br><br>// 根据 ID 查询<br>User user = userMapper.selectById(1);<br><br>// 插入<br>userMapper.insert(user);</code></pre><p>这些操作高度重复，而且每个表都要写一遍。MyBatis 虽然比 JDBC 好，但依然不够高效。</p><h2>MyBatis-Plus 是什么？</h2><p>MyBatis-Plus（简称 MP）是 MyBatis 的增强工具，它<strong>完全兼容 MyBatis</strong>，但在其基础上提供了：</p><ul><li>无侵入</li><li>强大的 CRUD 操作</li><li>支持 Lambda 形式调用</li><li>代码生成器</li><li>分页插件、性能分析插件等</li></ul><h2>一行代码实现 CRUD</h2><p>只需让你的 Mapper 继承 <code>BaseMapper&lt;T&gt;</code>：</p><pre><code>public interface UserMapper extends BaseMapper&lt;User&gt; {<br>    // 无需写任何方法，自带 insert、delete、update、select<br>}</code></pre><p>然后你就可以：</p><pre><code>userMapper.selectById(1);<br>userMapper.insert(user);<br>userMapper.deleteById(1);<br>userMapper.selectList(null); // 查询所有</code></pre><p>连 SQL 都不用写！</p><h2>条件构造器：告别拼接 SQL 字符串</h2><p>想查年龄大于 18 的用户？用 <code>QueryWrapper</code>：</p><pre><code>QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();<br>wrapper.gt(\"age\", 18);<br>List&lt;User&gt; users = userMapper.selectList(wrapper);</code></pre><p>支持链式调用：</p><pre><code>new QueryWrapper&lt;User&gt;()<br>    .eq(\"status\", 1)<br>    .like(\"name\", \"张\")<br>    .orderByDesc(\"create_time\");</code></pre><h2>代码生成器：一键生成 Entity、Mapper、Service、Controller</h2><p>MP 提供了代码生成器，连接数据库后，可以自动生成整套代码，节省大量重复劳动。</p><p>配置好表名，运行程序，瞬间生成：</p><ul><li>User.java（实体类）</li><li>UserMapper.java + XML</li><li>UserService.java</li><li>UserController.java</li></ul><h2>适用场景</h2><p>如果你的项目：</p><ul><li>使用 MyBatis</li><li>有大量单表 CRUD</li><li>希望提升开发速度</li></ul><p>那么 MyBatis-Plus 就是你的最佳选择。</p><h2>结语：工具的价值是解放生产力</h2><p>程序员的价值不在于写多少代码，而在于解决问题的效率。MyBatis-Plus 把我们从重复劳动中解放出来，让我们能更专注于业务逻辑和系统设计。善用工具，才是高级开发者的第一思维。</p>"
	},
	{
		"title": "C# 基础：.NET 开发者的起点",
		"date": "2025年10月20日",
		"category": "C#",
		"excerpt": "从语法到特性，C# 如何融合 Java 与 C++ 的优点，成为 Windows 开发和游戏开发的利器？",
		"content": "<h2>C# 是什么？</h2><p>C#（读作 C-Sharp）是微软在 2000 年推出的编程语言，运行在 .NET 平台上。它融合了 C++ 的强大和 Java 的简洁，是 Windows 桌面应用、游戏（Unity）、企业系统开发的主流语言。</p><h2>语法初体验：像 Java，但更现代</h2><p>HelloWorld 示例：</p><pre><code>using System;<br><br>class Program {<br>    static void Main() {<br>        Console.WriteLine(\"Hello, C#!\");<br>    }<br>}</code></pre><p>是不是和 Java 很像？但 C# 有一些更简洁的特性：</p><h3>1. 自动属性（Auto-Property）</h3><pre><code>public class Person {<br>    public string Name { get; set; } // 无需手动写字段<br>    public int Age { get; set; }<br>}</code></pre><h3>2. var 关键字：隐式类型</h3><pre><code>var name = \"Alice\"; // 编译器自动推断为 string</code></pre><h3>3. 字符串插值</h3><pre><code>string message = $\"Hello, {name}! You are {age} years old.\";</code></pre><h2>核心特性一览</h2><ul><li><strong>面向对象</strong>：类、继承、多态</li><li><strong>垃圾回收</strong>：自动内存管理</li><li><strong>委托与事件</strong>：实现回调和消息机制</li><li><strong>LINQ</strong>：用 SQL 风格查询集合</li><li><strong>异步编程</strong>：async/await 简化多线程</li></ul><h2>C# 的主要应用场景</h2><ul><li><strong>Windows 桌面应用</strong>：WPF、WinForms</li><li><strong>游戏开发</strong>：Unity 引擎的首选语言</li><li><strong>Web 后端</strong>：ASP.NET Core（跨平台！）</li><li><strong>企业系统</strong>：银行、ERP 等</li></ul><p>特别是 ASP.NET Core，性能极强，甚至可以与 Go 一较高下。</p><h2>开发工具：Visual Studio 是神器</h2><p>Visual Studio 是 C# 开发的终极利器，它提供了：</p><ul><li>智能提示</li><li>调试器</li><li>UI 设计器</li><li>性能分析</li><li>一键部署</li></ul><p>虽然重量级，但功能无出其右。</p><h2>C# 与 Java 的对比</h2><table border=\"1\" cellpadding=\"5\" cellspacing=\"0\" style=\"width:100%; text-align:center; margin:1rem 0; border-collapse:collapse;\"><tr><th>特性</th><th>C#</th><th>Java</th></tr><tr><td>平台</td><td>.NET（跨平台 via .NET Core）</td><td>JVM</td></tr><tr><td>语法简洁性</td><td>更高（var、属性、LINQ）</td><td>较严谨</td></tr><tr><td>异步支持</td><td>async/await 原生支持</td><td>需 Future/CompletableFuture</td></tr><tr><td>应用场景</td><td>Windows、游戏、Web</td><td>Android、后端、大数据</td></tr></table><h2>结语：C# 不只是“微软语言”</h2><p>随着 .NET Core 的跨平台发展，C# 已不再局限于 Windows。它是一门现代化、高性能、高生产力的语言。无论你是想做游戏、桌面软件，还是高性能 Web 服务，C# 都值得你深入学习。</p>"
	},
	{
		"title": "Vue.js 3 入门介绍",
		"date": "2025-10-28",
		"category": "前端",
		"content": "<h2>什么是 Vue.js 3？</h2>\n<p>Vue.js 3（简称 Vue3）是渐进式 JavaScript 框架 <strong>Vue.js</strong> 的最新主要版本，由尤雨溪开发并发布于 2020 年。它在性能、API 设计和模块化方面进行了重大改进，是构建现代 Web 用户界面的优秀选择。</p>\n\n<h2>核心新特性</h2>\n<ul>\n  <li><strong>Composition API</strong>：更灵活的逻辑组织方式，替代 Options API，尤其适合复杂组件。</li>\n  <li><strong>Proxy 响应式系统</strong>：取代 Vue2 的 Object.defineProperty，支持新增/删除属性的监听。</li>\n  <li><strong>更好的 TypeScript 支持</strong>：源码用 TS 重写，类型推断更精准。</li>\n  <li><strong>Tree-shaking 支持</strong>：按需引入功能，减小打包体积。</li>\n  <li><strong>Fragment & Teleport & Suspense</strong>：新增内置组件，提升结构灵活性。</li>\n</ul>\n\n<h2>快速示例：Composition API</h2>\n<pre><code>&lt;script setup&gt;\\nimport { ref, onMounted } from 'vue'\\n\\nconst count = ref(0)\\nconst increment = () =&gt; count.value++\\n\\nonMounted(() =&gt; console.log('组件已挂载'))\\n&lt;/script&gt;\\n\\n&lt;template&gt;\\n  &lt;button @click=\"increment\"&gt;点击 {{ count }} 次&lt;/button&gt;\\n&lt;/template&gt;</code></pre>\n\n<h2>与 Vue2 的主要区别</h2>\n<table border=\"1\" cellpadding=\"8\" style=\"border-collapse: collapse; width: 100%; margin: 1rem 0;\">\n  <tr><th>特性</th><th>Vue2</th><th>Vue3</th></tr>\n  <tr><td>响应式原理</td><td>Object.defineProperty</td><td>Proxy</td></tr>\n  <tr><td>根实例创建</td><td>new Vue()</td><td>createApp()</td></tr>\n  <tr><td>TS 支持</td><td>一般</td><td>原生支持</td></tr>\n  <tr><td>组合逻辑</td><td>mixins（有缺陷）</td><td>Composition API（推荐）</td></tr>\n</table>\n\n<h2>如何开始？</h2>\n<p>推荐使用官方脚手架：</p>\n<pre><code>npm create vue@latest\n# 或使用 Vite\nnpm create vite@latest my-vue-app -- --template vue</code></pre>\n\n<p>Vue3 已成为主流，建议新项目直接使用 Vue3 + &lt;script setup&gt; 语法，享受更简洁高效的开发体验。</p>"
	},
	{
		"title": "ASP.NET Core中的三种不同的服务生命周期模式",
		"date": "2025年10月28日",
		"category": "C#",
		"excerpt": "单例模式、瞬态模式、范围模式是ASP.NET Core依赖注入的核心概念，理解它们对于构建高效、可维护的应用程序至关重要。",
		"content": "<h2>什么是依赖注入（DI）？</h2><p>在深入探讨三种生命周期之前，我们先理解依赖注入。依赖注入是一种设计模式，它让类不再自己创建依赖对象，而是由外部容器（如ASP.NET Core的IoC容器）来提供。这带来了更好的可测试性、松耦合和可维护性。</p><p>ASP.NET Core内置了依赖注入容器，支持三种主要的服务生命周期。</p><h2>单例模式（Singleton）</h2><h3>定义与特点</h3><p>单例模式在整个应用程序生命周期内只创建一个实例。所有请求都共享同一个实例。</p><pre><code>// 注册单例服务\nservices.AddSingleton<IMyService, MyService>();\n\n// 或者在Startup.cs中：\nservices.AddSingleton<IMyService>(provider => new MyService(\"配置参数\"));</code></pre><h3>使用场景</h3><ul><li><strong>无状态服务</strong>：如配置服务、日志服务、缓存服务</li><li><strong>资源密集型对象</strong>：数据库连接池、HTTP客户端</li><li><strong>全局状态管理</strong>：应用程序级别的计数器、统计信息</li></ul><h3>注意事项</h3><p>单例服务必须是线程安全的，因为多个请求可能同时访问同一个实例。</p><h2>瞬态模式（Transient）</h2><h3>定义与特点</h3><p>瞬态模式每次请求都创建一个新的实例。这是最\"轻量级\"的生命周期。</p><pre><code>// 注册瞬态服务\nservices.AddTransient<IMyTransientService, MyTransientService>();</code></pre><h3>使用场景</h3><ul><li><strong>轻量级、无状态服务</strong>：数据转换器、验证器、计算服务</li><li><strong>需要独立状态的服务</strong>：每个操作都需要全新上下文的服务</li><li><strong>短期使用的服务</strong>：用完即弃，不占用长期资源</li></ul><h3>性能考虑</h3><p>频繁创建和销毁实例可能带来性能开销，但对于轻量级对象影响不大。</p><h2>范围模式（Scoped）</h2><h3>定义与特点</h3><p>范围模式在每个请求（HTTP请求）范围内创建同一个实例。同一个请求中的多个解析会得到相同的实例。</p><pre><code>// 注册范围服务\nservices.AddScoped<IMyScopedService, MyScopedService>();</code></pre><h3>使用场景</h3><ul><li><strong>数据库上下文</strong>：Entity Framework Core的DbContext</li><li><strong>用户会话相关服务</strong>：在当前请求中需要保持状态的服务</li><li><strong>工作单元模式</strong>：确保同一个请求中的所有操作使用相同的数据库连接</li></ul><h3>实际示例</h3><pre><code>public class ShoppingCartService : IShoppingCartService\n{\n    private List<CartItem> _items = new List<CartItem>();\n    \n    public void AddItem(CartItem item) => _items.Add(item);\n    public List<CartItem> GetItems() => _items;\n}\n\n// 注册为Scoped，这样每个HTTP请求都有独立的购物车</code></pre><h2>三种模式的对比</h2><table border=\"1\" cellpadding=\"8\" style=\"border-collapse: collapse; width: 100%; margin: 1rem 0;\">\n  <tr style=\"background-color: #f5f5f5;\">\n    <th>生命周期</th>\n    <th>实例创建时机</th>\n    <th>适用场景</th>\n    <th>性能影响</th>\n  </tr>\n  <tr>\n    <td><strong>单例（Singleton）</strong></td>\n    <td>第一次请求时创建，整个应用生命周期内复用</td>\n    <td>配置服务、日志服务、缓存</td>\n    <td>最优（只创建一次）</td>\n  </tr>\n  <tr>\n    <td><strong>范围（Scoped）</strong></td>\n    <td>每个HTTP请求开始时创建，请求结束时销毁</td>\n    <td>数据库上下文、用户会话服务</td>\n    <td>中等</td>\n  </tr>\n  <tr>\n    <td><strong>瞬态（Transient）</strong></td>\n    <td>每次请求服务时都创建新实例</td>\n    <td>轻量级工具类、数据转换器</td>\n    <td>较高（频繁创建销毁）</td>\n  </tr>\n</table><h2>实际开发中的最佳实践</h2><h3>1. 选择合适的生命周期</h3><p>根据服务的用途和资源需求选择最合适的生命周期。错误的生命周期选择可能导致内存泄漏或性能问题。</p><h3>2. 避免生命周期不匹配</h3><pre><code>// 错误示例：单例服务依赖瞬态服务\npublic class SingletonService\n{\n    private readonly TransientService _transientService;\n    \n    public SingletonService(TransientService transientService)\n    {\n        _transientService = transientService; // 这会导致问题！\n    }\n}</code></pre><p>单例服务不应该依赖瞬态或范围服务，因为单例服务会\"捕获\"这些依赖，导致它们也变成单例。</p><h3>3. 使用工厂模式解决复杂依赖</h3><pre><code>// 使用工厂来创建需要参数的瞬态服务\nservices.AddTransient<IService>(provider => \n{\n    var config = provider.GetService<IConfiguration>();\n    return new Service(config.GetValue<string>(\"ApiKey\"));\n});</code></pre><h2>在ASP.NET Core中的配置</h2><pre><code>public void ConfigureServices(IServiceCollection services)\n{\n    // 单例服务\n    services.AddSingleton<ICacheService, CacheService>();\n    \n    // 范围服务  \n    services.AddScoped<IUserService, UserService>();\n    \n    // 瞬态服务\n    services.AddTransient<IEmailService, EmailService>();\n    \n    // 已有的单例实例\n    var logger = new Logger();\n    services.AddSingleton<ILogger>(logger);\n}</code></pre><h2>调试技巧</h2><p>要验证服务的生命周期是否正确，可以在构造函数中添加日志：</p><pre><code>public class MyService : IMyService\n{\n    private readonly Guid _instanceId = Guid.NewGuid();\n    \n    public MyService(ILogger<MyService> logger)\n    {\n        logger.LogInformation($\"MyService实例已创建，ID: {_instanceId}\");\n    }\n    \n    public Guid GetInstanceId() => _instanceId;\n}</code></pre><p>通过观察日志中的实例ID，可以确认服务的生命周期是否符合预期。</p><h2>结语：选择合适的生命周期是架构设计的关键</h2><p>理解并正确使用ASP.NET Core的三种服务生命周期模式，是构建高性能、可维护应用程序的基础。单例模式适合全局共享的无状态服务，范围模式完美匹配HTTP请求生命周期，瞬态模式则为轻量级临时服务提供了解决方案。在实际开发中，要根据服务的具体用途、资源需求和线程安全性要求来做出明智的选择。</p><p>记住：正确的生命周期选择不仅能提升性能，还能避免许多难以调试的内存泄漏和状态污染问题。</p>"
	},
	{
		"title": "Redis深度解析：从高速缓存到分布式系统核心",
		"date": "2025年10月28日",
		"category": "数据库",
		"excerpt": "Redis不仅仅是缓存，更是现代分布式系统的'高速工作记忆'。深入了解这款高性能内存数据库的核心原理、数据结构与应用场景。",
		"content": "<h2>Redis是什么？为什么它如此重要？</h2><p>Redis（Remote Dictionary Server）是一个开源的基于内存的数据结构存储系统，由Salvatore Sanfilippo于2009年开发[citation:4]。在现代应用架构中，Redis已经从一个单纯的缓存工具演变为支撑整个系统高速运转的\"神经系统\"[citation:1]。</p><p><strong>核心定位：</strong>Redis通过内存存储与丰富数据结构实现微秒级响应，完美解决了磁盘数据库在高并发场景下的性能瓶颈问题[citation:1]。官方数据显示，Redis能达到10w+的QPS（每秒查询速度），这主要得益于其内存存储特性和高效的数据结构设计[citation:10]。</p><h2>Redis的核心特性与优势</h2><table border=\"1\" cellpadding=\"8\" style=\"border-collapse: collapse; width: 100%; margin: 1rem 0;\">\n  <tr style=\"background-color: #f5f5f5;\">\n    <th>特性</th>\n    <th>说明</th>\n    <th>实际价值</th>\n  </tr>\n  <tr>\n    <td><strong>高性能</strong></td>\n    <td>所有数据存储在内存中，读写速度极快</td>\n    <td>微秒级响应，解决高并发瓶颈</td>\n  </tr>\n  <tr>\n    <td><strong>数据结构丰富</strong></td>\n    <td>支持String、List、Set、Hash、ZSet等[citation:4]</td>\n    <td>直接操作复杂数据结构，减少网络传输</td>\n  </tr>\n  <tr>\n    <td><strong>持久化支持</strong></td>\n    <td>提供RDB快照和AOF日志两种机制[citation:4]</td>\n    <td>内存数据安全落盘，防止宕机丢失</td>\n  </tr>\n  <tr>\n    <td><strong>原子操作</strong></td>\n    <td>所有操作都是原子的[citation:4]</td>\n    <td>保证数据一致性，无需额外锁机制</td>\n  </tr>\n  <tr>\n    <td><strong>分布式支持</strong></td>\n    <td>主从复制、哨兵模式、集群部署[citation:4]</td>\n    <td>高可用性，水平扩展能力</td>\n  </tr>\n</table><h2>Redis数据结构详解：超越简单键值存储</h2><p>Redis的真正精髓在于它是一个\"数据结构服务器\"（Data Structure Server），而不仅仅是简单的键值存储[citation:1]。</p><h3>1. String（字符串）</h3><p>最基础的数据类型，可以存储数字、文本、JSON等，最大512MB[citation:10]。</p><pre><code>SET user:1:name \"张三\"\nGET user:1:name\nINCR article:views  # 原子自增</code></pre><p><strong>应用场景：</strong>缓存HTML片段、计数器、分布式锁[citation:1][citation:4]。</p><h3>2. Hash（哈希表）</h3><p>适合存储对象结构，支持单独字段的读写[citation:1]。</p><pre><code>HSET user:1 name \"李四\" age 25 email \"lisi@example.com\"\nHGET user:1 name  # 返回\"李四\"\nHINCRBY user:1 age 1  # 年龄增加1</code></pre><p><strong>应用场景：</strong>用户信息、商品属性等对象数据存储[citation:4]。</p><h3>3. List（列表）</h3><p>有序、可重复的字符串列表，支持双向操作[citation:1]。</p><pre><code>LPUSH news:latest \"新闻ID1\"  # 左侧插入\nLRANGE news:latest 0 9     # 获取最新10条\nRPOP news:latest          # 右侧弹出</code></pre><p><strong>应用场景：</strong>消息队列、最新消息列表、任务调度[citation:1][citation:4]。</p><h3>4. Set（集合）</h3><p>无序且元素唯一的集合，支持交集、并集、差集等操作[citation:4]。</p><pre><code>SADD user:1:follows 1001 1002 1003  # 添加关注用户\nSADD user:2:follows 1002 1003 1004\nSINTER user:1:follows user:2:follows  # 返回共同关注[1002, 1003]</code></pre><p><strong>应用场景：</strong>共同关注、标签系统、唯一性统计[citation:1][citation:4]。</p><h3>5. Sorted Set（有序集合）</h3><p>带权重的集合，按分数排序，是排行榜实现的利器[citation:1]。</p><pre><code>ZADD leaderboard 5000 \"玩家A\"  # 添加玩家和分数\nZADD leaderboard 6000 \"玩家B\"\nZREVRANGE leaderboard 0 9 WITHSCORES  # 获取前十名</code></pre><p><strong>应用场景：</strong>游戏排行榜、热度排序、延迟队列[citation:1][citation:4]。</p><h2>Redis在ASP.NET Core中的实际应用</h2><h3>1. 会话存储（Session Storage）</h3><p>将用户登录状态、购物车信息存储在Redis中，实现分布式会话[citation:9]。</p><pre><code>// 配置服务\nservices.AddDistributedRedisCache(options =>\n{\n    options.Configuration = \"localhost\";\n});\n\nservices.AddSession(options =>\n{\n    options.IdleTimeout = TimeSpan.FromMinutes(10);\n});\n\n// 使用Session\nHttpContext.Session.SetString(\"userid\", \"1000\");</code></pre><h3>2. 缓存系统</h3><p>缓存数据库查询结果，显著提升应用响应速度[citation:1][citation:7]。</p><pre><code>// 使用StackExchange.Redis连接Redis\nprivate static Lazy<ConnectionMultiplexer> lazyConnection = new Lazy<ConnectionMultiplexer>(() =>\n{\n    return ConnectionMultiplexer.Connect(\"localhost,abortConnect=false\");\n});</code></pre><h3>3. 消息队列</h3><p>使用List结构实现轻量级消息队列[citation:1][citation:4]。</p><pre><code>// 生产者：推送消息\ndb.ListLeftPush(\"message_queue\", \"任务数据\");\n\n// 消费者：处理消息\nstring message = db.ListRightPop(\"message_queue\");</code></pre><h2>Redis的安装与配置</h2><h3>Linux环境下安装</h3><p><strong>使用包管理器安装（Ubuntu/Debian）：</strong>[citation:2]</p><pre><code>sudo apt update\nsudo apt install redis-server</code></pre><p><strong>编译安装最新版本：</strong>[citation:5]</p><pre><code>wget http://download.redis.io/releases/redis-6.0.1.tar.gz\ntar -zxf redis-6.0.1.tar.gz\ncd redis-6.0.1\nmake\nmake install</code></pre><h3>核心配置项</h3><ul>\n<li><strong>bind</strong>：设置监听IP（127.0.0.1只允许本地连接）[citation:2]</li>\n<li><strong>port</strong>：设置监听端口，默认6379[citation:2]</li>\n<li><strong>daemonize</strong>：是否以守护进程运行[citation:5]</li>\n<li><strong>requirepass</strong>：设置访问密码[citation:2]</li>\n<li><strong>maxmemory</strong>：设置最大内存使用量[citation:4]</li>\n</ul><h2>Redis持久化机制：数据安全的关键</h2><p>Redis虽然是内存数据库，但提供了两种持久化机制来保证数据不丢失[citation:4]：</p><h3>RDB（快照）模式</h3><p>定期生成数据快照，适合备份和快速恢复。</p><pre><code>save 900 1     # 900秒内有1次修改就触发RDB\nsave 300 10    # 300秒内有10次修改触发RDB</code></pre><p><strong>优点：</strong>文件紧凑，恢复速度快<br><strong>缺点：</strong>可能丢失最后一次快照后的数据</p><h3>AOF（追加文件）模式</h3><p>记录每次写操作，宕机后重放恢复。</p><pre><code>appendonly yes           # 开启AOF\nappendfsync everysec    # 每秒同步一次</code></pre><p><strong>优点：</strong>数据安全性更高<br><strong>缺点：</strong>文件更大，恢复较慢</p><h2>Redis高可用与集群方案</h2><h3>主从复制（Replication）</h3><p>实现数据备份和读写分离，提高系统可用性[citation:1]。</p><h3>哨兵模式（Sentinel）</h3><p>提供自动故障转移，在主节点宕机时选举新主节点[citation:1]。</p><h3>集群模式（Cluster）</h3><p>通过数据分片将数据分布到多个节点，实现水平扩展[citation:1]。</p><h2>性能优化与最佳实践</h2><h3>内存优化策略</h3><ul>\n<li><strong>设置合理过期时间：</strong>避免内存被长期占用[citation:4]</li>\n<li><strong>使用适当数据结构：</strong>根据场景选择最合适的数据类型</li>\n<li><strong>避免大Key：</strong>单个Key过大会造成阻塞[citation:4]</li>\n</ul><h3>内存淘汰策略</h3><p>当内存占满时，Redis会触发淘汰策略[citation:4]：</p><ul>\n<li><strong>allkeys-lru：</strong>所有键中淘汰最少使用的</li>\n<li><strong>volatile-lru：</strong>只淘汰设置了过期时间的键</li>\n<li><strong>allkeys-random：</strong>所有键中随机淘汰</li>\n<li><strong>noeviction：</strong>默认策略，内存满时报错</li>\n</ul><h2>常见问题与解决方案</h2><h3>1. 缓存穿透</h3><p><strong>问题：</strong>查询不存在的数据，绕过缓存直接访问数据库<br><strong>解决方案：</strong>缓存空对象或使用布隆过滤器</p><h3>2. 缓存雪崩</h3><p><strong>问题：</strong>大量缓存同时过期，导致数据库压力激增<br><strong>解决方案：</strong>设置随机过期时间，使用集群提高可用性</p><h3>3. 数据一致性</h3><p><strong>问题：</strong>缓存与数据库数据不一致<br><strong>解决方案：</strong>采用\"先更新数据库，再删除缓存\"策略[citation:7]</p><h2>Redis在云原生时代的演进</h2><p>随着云计算和容器化技术的普及，Redis也迎来了新的发展机遇[citation:1]：</p><ul>\n<li><strong>托管服务：</strong>AWS ElastiCache、Azure Cache for Redis等让开发者无需关心底层运维[citation:1]</li>\n<li><strong>模块化架构：</strong>RedisSearch、RedisJSON等模块提供全文搜索、文档存储等更强能力[citation:1]</li>\n<li><strong>容器化部署：</strong>完美适配Docker、Kubernetes等云原生环境</li>\n</ul><h2>结语：Redis是现代应用架构的基石</h2><p>Redis已经从单纯的缓存工具演变为支撑现代互联网应用高速运转的核心组件[citation:1]。它通过内存存储、丰富数据结构和原子操作等特性，为高并发、实时性要求高的应用提供了强有力的支持。</p><p>在微服务、云原生架构成为主流的今天，熟练掌握Redis不仅能够解决性能瓶颈问题，更能为系统设计提供更多可能性。无论是缓存、会话管理、消息队列还是分布式锁，Redis都展现出了其不可替代的价值。</p><p>正如Redis创造者Salvatore Sanfilippo所设想的那样，Redis已经成为数字时代的\"高速工作记忆\"，在人工智能、物联网、实时分析等前沿领域继续发挥着关键作用[citation:1]。</p>"
	},
	{
		"title": "C#中的数据库迁移：从零理解EF Core上下文与模型映射",
		"date": "2025年10月29日",
		"category": "C#",
		"excerpt": "Entity Framework Core中的DbContext不仅是数据访问的入口，更是模型与数据库之间的桥梁。深入解析其构造、配置与常见陷阱。",
		"content": "<h2>什么是DbContext？它为何如此关键？</h2><p>在.NET应用中，<strong>Entity Framework Core（EF Core）</strong> 是最主流的ORM框架，而 <code>DbContext</code> 正是其核心入口。它封装了数据库连接、实体映射、变更跟踪、查询执行与事务管理，是应用程序与数据库之间的“桥梁”[citation:1]。</p><p>一个设计良好的 <code>DbContext</code> 不仅能提升开发效率，还能显著影响应用的性能与可维护性。本文将通过一个真实示例，深入剖析其结构、生命周期与最佳实践。</p><h2>一个典型的EF Core上下文定义</h2><p>以下是一个常见的 <code>TestDbContext</code> 实现：</p><pre><code>using Microsoft.EntityFrameworkCore;\n\nnamespace EFCore.PerformanceOptimization\n{\n    public class TestDbContext : DbContext\n    {\n        public TestDbContext()\n        {\n            Database.EnsureCreated();\n        }\n\n        public TestDbContext(DbContextOptions<TestDbContext> options) : base(options)\n        {\n            Database.EnsureCreated();\n        }\n        \n        public DbSet<Student> Students { get; set; }\n        \n        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n        {\n            optionsBuilder.UseSqlServer(@\"data source=.;database=db_student;Encrypt=True;Trusted_Connection=True;TrustServerCertificate=True;\");\n        }\n\n        protected override void OnModelCreating(ModelBuilder modelBuilder)\n        {\n            base.OnModelCreating(modelBuilder);\n            modelBuilder.ApplyConfigurationsFromAssembly(this.GetType().Assembly);\n        }\n    }\n}</code></pre><p>这段代码看似简单，实则蕴含多个关键设计决策。我们来逐层解析。</p><h2>构造函数：两种初始化方式</h2><h3>无参构造函数</h3><pre><code>public TestDbContext()\n{\n    Database.EnsureCreated();\n}</code></pre><p>该构造函数调用 <code>Database.EnsureCreated()</code>，其作用是：<strong>如果数据库不存在，则自动创建数据库和表结构</strong>。</p><p><strong>优点</strong>：开发初期快速启动，无需手动建库。<br><strong>缺点</strong>：</p><ul><li>不支持迁移（Migration），无法追踪数据库变更历史</li><li>每次创建上下文都会检查数据库，影响性能</li><li>生产环境应避免自动建库</li></ul><h3>依赖注入构造函数</h3><pre><code>public TestDbContext(DbContextOptions<TestDbContext> options) : base(options)\n{\n    Database.EnsureCreated();\n}</code></pre><p>这是ASP.NET Core中推荐的方式，通过依赖注入容器传入配置选项，支持更灵活的配置管理。</p><p><strong>问题</strong>：仍然调用了 <code>EnsureCreated()</code>，属于副作用操作，应在应用启动时统一处理。</p><h2>DbSet属性：实体与表的映射</h2><pre><code>public DbSet<Student> Students { get; set; }</code></pre><p>这行代码定义了一个实体集合，EF Core会将其映射到数据库中的一个表。</p><table border=\"1\" cellpadding=\"8\" style=\"border-collapse: collapse; width: 100%; margin: 1rem 0;\">\n  <tr style=\"background-color: #f5f5f5;\">\n    <th>C# 实体类</th>\n    <th>DbSet 属性名</th>\n    <th>生成的数据库表名</th>\n    <th>所属数据库</th>\n  </tr>\n  <tr>\n    <td><code>Student</code></td>\n    <td><code>Students</code></td>\n    <td><code>Students</code></td>\n    <td><code>db_student</code></td>\n  </tr>\n</table><p>最终在SQL Server中生成的表为：<code>db_student.dbo.Students</code>，其中：</p><ul><li><code>db_student</code>：来自连接字符串中的 <code>database=</code> 配置</li><li><code>Students</code>：由 <code>DbSet</code> 属性名决定</li><li><code>dbo</code>：SQL Server默认架构</li></ul><h2>OnConfiguring：数据库连接与行为配置</h2><pre><code>protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n{\n    optionsBuilder.UseSqlServer(@\"data source=.;database=db_student;Encrypt=True;Trusted_Connection=True;TrustServerCertificate=True;\");\n}</code></pre><p>此方法用于配置数据库提供程序和连接字符串。</p><h3>连接字符串详解</h3><ul>\n<li><strong>data source=.</strong>：连接本地SQL Server实例</li>\n<li><strong>database=db_student</strong>：使用或创建名为 <code>db_student</code> 的数据库</li>\n<li><strong>Encrypt=True</strong>：启用SSL加密</li>\n<li><strong>Trusted_Connection=True</strong>：使用Windows身份验证</li>\n<li><strong>TrustServerCertificate=True</strong>：跳过证书验证（开发环境可用）</li>\n</ul><p><strong>建议</strong>：连接字符串应从 <code>appsettings.json</code> 读取，避免硬编码。</p><h2>OnModelCreating：模型的精细化控制</h2><pre><code>protected override void OnModelCreating(ModelBuilder modelBuilder)\n{\n    base.OnModelCreating(modelBuilder);\n    modelBuilder.ApplyConfigurationsFromAssembly(this.GetType().Assembly);\n}</code></pre><p>这是模型配置的核心方法，用于：</p><ul>\n<li>定义实体间关系（一对多、多对多）</li>\n<li>配置字段约束（长度、是否可空）</li>\n<li>指定表名、架构、索引等</li>\n</ul><p><code>ApplyConfigurationsFromAssembly</code> 是一种优秀实践，它自动加载所有实现了 <code>IEntityTypeConfiguration&lt;T&gt;</code> 的配置类，实现关注点分离。</p><h2>常见问题与最佳实践</h2><h3>1. 禁止在构造函数中调用 EnsureCreated()</h3><p>该操作应在应用启动时执行一次：</p><pre><code>// 在Program.cs中\nusing (var scope = app.Services.CreateScope())\n{\n    var context = scope.ServiceProvider.GetRequiredService<TestDbContext>();\n    context.Database.EnsureCreated();\n}</code></pre><h3>2. 使用Migrations替代 EnsureCreated</h3><p>Migrations支持版本化数据库变更，适合团队协作：</p><pre><code>dotnet ef migrations add Init\ndotnet ef database update</code></pre><h3>3. 统一EF Core包版本</h3><p>确保所有相关包版本一致，避免运行时异常：</p><pre><code>&lt;PackageReference Include=\"Microsoft.EntityFrameworkCore.SqlServer\" Version=\"8.0.4\" /&gt;\n&lt;PackageReference Include=\"Microsoft.EntityFrameworkCore.Tools\" Version=\"8.0.4\" /&gt;\n&lt;PackageReference Include=\"Microsoft.EntityFrameworkCore.Design\" Version=\"8.0.4\" /&gt;</code></pre><h3>4. 命名规范</h3><ul>\n<li>实体类使用单数：<code>Student</code></li>\n<li>DbSet属性使用复数：<code>Students</code></li>\n<li>命名空间避免使用中文</li>\n</ul><h2>结语：构建高效、可维护的EF Core应用</h2><p><code>DbContext</code> 是EF Core的“心脏”，正确理解其生命周期、配置方式与设计模式，是构建高性能.NET应用的基础。避免在构造函数中做副作用操作，使用Migrations管理数据库变更，遵循命名与架构规范，能让团队协作更顺畅，系统更稳定。</p><p>记住：好的数据库访问层，不仅能让数据“动起来”，更能为业务的快速迭代提供坚实支撑。</p>"
	},
	{
		"title": "图形界面 vs 命令行：为何EF Core生成Razor页面在VS中失败而命令行成功？",
		"date": "2025年10月30日",
		"category": "C#",
		"excerpt": "深入解析Visual Studio图形界面生成Razor页面失败的根本原因，结合项目配置与工具行为差异，揭示为何命令行方式能成功执行。",
		"content": "<h2>问题现象：图形界面报错，命令行却成功</h2><p>在开发ASP.NET Core Web应用时，我们常使用 <strong>Entity Framework Core</strong> 进行数据访问，并通过 <strong>Razor Pages</strong> 实现前后端分离的页面逻辑。然而，在实际操作中，你可能会遇到一个令人困惑的现象：</p><p><strong>使用 Visual Studio 图形界面“添加” → “新项” → “Razor 页面 (使用实体框架)”时，提示错误：</strong></p><img src=\"errimages/a1.png?text=Microsoft+Visual+Studio+Error+Dialog\" alt=\"Visual Studio 错误对话框\" style=\"max-width: 100%; margin: 1rem 0; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);\"><p>错误信息：<br><code>运行所选代码生成器时出错：\n“程序包还原失败。正在回滚 'EF Core的性能优化' 的程序包更改。”</code></p><p>但当你切换到 <strong>命令行</strong> 执行相同操作时，一切正常：</p><pre><code>dotnet aspnet-codegenerator razorpage -m Student -dc TestDbContext -udl -outDir Pages/Student</code></pre><p>这究竟是为什么？本文将结合你之前的项目配置和工具行为，深入剖析这一现象的本质。</p><h2>根本原因：工具链版本不一致与依赖冲突</h2><p>虽然你的项目文件（<code>.csproj</code>）中已经正确引用了 EF Core 包：</p><pre><code>&lt;PackageReference Include=\"Microsoft.EntityFrameworkCore\" Version=\"8.0.11\" /&gt;\n&lt;PackageReference Include=\"Microsoft.EntityFrameworkCore.Design\" Version=\"8.0.11\" /&gt;\n&lt;PackageReference Include=\"Microsoft.EntityFrameworkCore.SqlServer\" Version=\"8.0.11\" /&gt;\n&lt;PackageReference Include=\"Microsoft.EntityFrameworkCore.Tools\" Version=\"8.0.11\" /&gt;</code></pre><p>但 <strong>Visual Studio 图形界面使用的代码生成器（Code Generator）是独立的、内置的工具</strong>，它并不直接读取你的项目文件中的 NuGet 配置，而是依赖于全局安装的 <code>Microsoft.VisualStudio.Web.CodeGeneration.Design</code> 包及其内部的 <code>Microsoft.EntityFrameworkCore</code> 版本绑定。</p><p>当 VS 尝试运行生成器时，它会：</p><ol>\n<li>检查当前项目是否包含必要的 EF Core 包</li>\n<li>尝试加载 <code>Microsoft.EntityFrameworkCore</code> 程序集</li>\n<li>发现版本不匹配或依赖缺失时，触发包还原</li>\n<li>由于某些原因（如网络、缓存、权限），包还原失败，导致回滚</li>\n</ol><p>而 <strong>命令行工具 <code>dotnet aspnet-codegenerator</code> 是基于 CLI 的，它直接从项目上下文加载依赖</strong>，因此不受 VS 内部工具链版本控制的影响。</p><h2>关键对比：图形界面 vs 命令行的行为差异</h2><table border=\"1\" cellpadding=\"8\" style=\"border-collapse: collapse; width: 100%; margin: 1rem 0;\">\n  <tr style=\"background-color: #f5f5f5;\">\n    <th>对比维度</th>\n    <th>Visual Studio 图形界面</th>\n    <th>命令行 <code>dotnet aspnet-codegenerator</code></th>\n  </tr>\n  <tr>\n    <td><strong>工具来源</strong></td>\n    <td>VS 内置代码生成器，依赖全局安装的 <code>Microsoft.VisualStudio.Web.CodeGeneration.Design</code></td>\n    <td>CLI 工具，由 <code>dotnet tool install</code> 安装，直接使用项目依赖</td>\n  </tr>\n  <tr>\n    <td><strong>依赖解析方式</strong></td>\n    <td>尝试从全局 NuGet 缓存加载 EF Core 程序集，可能版本不匹配</td>\n    <td>从项目本地包目录加载，确保版本一致</td>\n  </tr>\n  <tr>\n    <td><strong>错误处理机制</strong></td>\n    <td>一旦包还原失败，立即回滚并显示错误</td>\n    <td>更灵活，支持重试和详细日志输出</td>\n  </tr>\n  <tr>\n    <td><strong>环境隔离性</strong></td>\n    <td>受 VS IDE 状态影响，可能被其他项目干扰</td>\n    <td>完全独立，只依赖当前项目上下文</td>\n  </tr>\n</table><h2>解决方案与最佳实践</h2><h3>1. 使用命令行替代图形界面</h3><p>最可靠的方式是放弃图形界面，使用命令行生成 Razor 页面：</p><pre><code>dotnet aspnet-codegenerator razorpage -m Student -dc TestDbContext -udl -outDir Pages/Student</code></pre><p>优点：</p><ul>\n<li>版本一致性高</li>\n<li>错误信息更清晰</li>\n<li>适合 CI/CD 流水线</li>\n</ul><h3>2. 统一 EF Core 包版本</h3><p>确保所有相关包版本一致，避免因版本冲突导致的问题：</p><pre><code>&lt;PackageReference Include=\"Microsoft.EntityFrameworkCore\" Version=\"8.0.8\" /&gt;\n&lt;PackageReference Include=\"Microsoft.EntityFrameworkCore.Design\" Version=\"8.0.8\" /&gt;\n&lt;PackageReference Include=\"Microsoft.EntityFrameworkCore.SqlServer\" Version=\"8.0.8\" /&gt;\n&lt;PackageReference Include=\"Microsoft.EntityFrameworkCore.Tools\" Version=\"8.0.8\" /&gt;\n&lt;PackageReference Include=\"Microsoft.VisualStudio.Web.CodeGeneration.Design\" Version=\"8.0.7\" /&gt;</code></pre><p>推荐使用稳定版本（如 8.0.8），避免预发布版本（如 8.0.11）带来的不确定性。</p><h3>3. 使用局部工具（推荐）</h3><p>避免全局安装工具，使用局部工具管理：</p><pre><code>dotnet new tool-manifest\ndotnet tool install dotnet-aspnet-codegenerator</code></pre><p>这样可以确保每个项目使用独立的工具版本，避免冲突。</p><h3>4. 检查项目命名空间</h3><p>你项目的命名空间为 <code>EF_Core的性能优化</code>，包含中文字符，可能导致某些工具无法正确解析。建议修改为：</p><pre><code>namespace EFCore.PerformanceOptimization</code></pre><h2>结语：理解工具链是高效开发的关键</h2><p>现代开发工具虽然提供了丰富的图形界面，但其背后复杂的依赖管理和版本控制机制，常常成为隐藏的陷阱。正如你在本次实践中所经历的，<strong>图形界面的“便利”有时会掩盖底层的版本冲突问题</strong>。</p><p>而命令行工具，虽然需要手动输入命令，但其透明性和可预测性，往往能提供更稳定的体验。理解这些差异，不仅能帮你解决当前问题，更能提升你在复杂项目中的调试能力和系统设计思维。</p><p>记住：当图形界面失效时，不要慌张，打开终端，用命令行重新连接你的项目与工具——这才是开发者真正的力量所在。</p>"
	},
	{
		"title": "C#中的readonly：深入理解只读字段的用法与陷阱",
		"date": "2025年10月31日",
		"category": "C#",
		"excerpt": "readonly不仅是字段修饰符，更是代码安全的守护者。深入解析其与const的区别、引用类型陷阱及最佳实践。",
		"content": "<h2>什么是readonly？它为何如此关键？</h2><p>在C#开发中，<strong>数据的不可变性</strong>是构建健壮、可维护应用的核心原则之一。而 <code>readonly</code> 正是实现这一原则的重要工具。它允许你在对象初始化阶段赋值一次，之后便无法更改，从而防止意外修改，提升代码安全性[citation:1]。</p><p>与 <code>const</code> 不同，<code>readonly</code> 支持运行时赋值，适用范围更广。本文将通过真实示例，深入剖析 <code>readonly</code> 的工作原理、常见陷阱与最佳实践。</p><h2>一个典型的readonly字段使用场景</h2><p>以下是一个常见的服务类，使用 <code>readonly</code> 确保依赖项不会被意外修改：</p><pre><code>public class OrderService\n{\n    private readonly IOrderRepository _repository;\n    private readonly ILogger _logger;\n    private readonly string _environment;\n\n    public OrderService(IOrderRepository repository, ILogger logger)\n    {\n        _repository = repository ?? throw new ArgumentNullException(nameof(repository));\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n        _environment = Environment.GetEnvironmentVariable(\"ASPNET_ENV\") ?? \"Development\";\n    }\n\n    public void ProcessOrder(Order order)\n    {\n        // 使用只读字段，确保它们在方法中不会被重新赋值\n        _logger.LogInformation($\"Processing order in {_environment} environment.\");\n        _repository.Save(order);\n    }\n}</code></pre><p>在这个例子中，所有依赖项都被声明为 <code>readonly</code>，这不仅是一种防御性编程，也是向其他开发者传达“这些字段不应被修改”的明确信号。</p><h2>readonly vs const：关键区别</h2><p>虽然两者都表示“不可变”，但它们的使用场景和机制截然不同。</p><table border=\"1\" cellpadding=\"8\" style=\"border-collapse: collapse; width: 100%; margin: 1rem 0;\">\n  <tr style=\"background-color: #f5f5f5;\">\n    <th>特性</th>\n    <th><code>const</code></th>\n    <th><code>readonly</code></th>\n  </tr>\n  <tr>\n    <td><strong>赋值时机</strong></td>\n    <td>编译时（compile-time）</td>\n    <td>运行时（run-time），构造函数或声明时</td>\n  </tr>\n  <tr>\n    <td><strong>数据类型</strong></td>\n    <td>仅限基本类型、string、enum</td>\n    <td>任何类型（包括类、结构体）</td>\n  </tr>\n  <tr>\n    <td><strong>静态性</strong></td>\n    <td>隐式 <code>static</code></td>\n    <td>可为实例或静态字段</td>\n  </tr>\n  <tr>\n    <td><strong>是否可变</strong></td>\n    <td>完全不可变</td>\n    <td>构造函数外不可变</td>\n  </tr>\n</table><h2>readonly的初始化时机</h2><h3>1. 声明时直接赋值</h3><pre><code>public class Settings\n{\n    public readonly string Version = \"1.0.0\"; // ✅ 合法\n    public readonly bool IsDebug = true;\n}</code></pre><h3>2. 构造函数中赋值</h3><pre><code>public class Person\n{\n    private readonly string _name;\n    private readonly int _birthYear;\n\n    public Person(string name, int birthYear)\n    {\n        _name = name;           // ✅ 构造函数中赋值\n        _birthYear = birthYear; // ✅ 合法\n    }\n}</code></pre><p>一旦构造完成，这些字段就无法再被修改，任何尝试都会导致编译错误。</p><h2>重要陷阱：引用类型的readonly</h2><p><code>readonly</code> 对引用类型的行为是开发者最容易误解的地方。</p><p>它<strong>只保证字段的引用不变</strong>，但<strong>不保证对象内部状态不变</strong>。</p><pre><code>public class Example\n{\n    private readonly List<string> _items = new List<string>();\n\n    public void Demo()\n    {\n        _items.Add(\"Hello\"); // ✅ 合法！可以修改对象内容\n\n        _items = new List<string>(); // ❌ 错误！不能重新赋值给 _items\n    }\n}</code></pre><p>因此，如果你需要完全不可变的集合，应使用 <code>ReadOnlyCollection&lt;T&gt;</code> 或 <code>ImmutableList&lt;T&gt;</code>。</p><h2>静态readonly字段</h2><p>你也可以定义静态的只读字段，通常用于全局配置：</p><pre><code>public class App\n{\n    public static readonly string AppName;\n\n    static App()\n    {\n        AppName = \"MyApp\"; // ✅ 静态构造函数中赋值\n    }\n}</code></pre><p>静态 <code>readonly</code> 字段只能在<strong>静态构造函数</strong>中赋值。</p><h2>常见问题与最佳实践</h2><h3>1. 尽量使用readonly</h3><p>将所有“只在构造时赋值”的字段标记为 <code>readonly</code>，这是一种良好的防御性编程习惯。现代IDE（如Visual Studio）会建议你这样做。</p><h3>2. 结合属性暴露只读性</h3><p>使用 <code>readonly</code> 字段 + 只读属性，提供更好的封装：</p><pre><code>public class Person\n{\n    private readonly string _name;\n\n    public Person(string name)\n    {\n        _name = name;\n    }\n\n    public string Name => _name; // 只读属性\n}</code></pre><h3>3. 注意命名空间中的中文字符</h3><p>如你之前遇到的EF Core生成问题，命名空间中包含中文（如 <code>性能优化</code>）可能导致某些工具解析失败。建议使用英文命名：</p><pre><code>namespace MyApplication.Services</code></pre><h2>结语：readonly是代码安全的基石</h2><p><code>readonly</code> 不仅是一个语法特性，更是一种<strong>设计哲学</strong>——通过限制可变性来提升代码的可读性、可维护性和线程安全性。</p><p>在依赖注入、配置管理、实体设计等场景中，合理使用 <code>readonly</code> 能有效防止bug，让团队协作更加顺畅。</p><p>记住：<strong>能用 readonly 的地方，绝不用普通字段</strong>。让编译器帮你守护代码的纯洁性，这才是现代C#开发的优雅之道。</p>"
	},
	{
		"title": "C#中的record：现代数据建模的优雅语法",
		"date": "2025年10月31日",
		"category": "C#",
		"excerpt": "record不仅是语法糖，更是不可变数据设计的革命。深入解析其与class的区别、值语义陷阱及最佳实践。",
		"content": "<h2>什么是record？它为何如此关键？</h2><p>在C#开发中，<strong>数据的不可变性与简洁表达</strong>是构建现代化、可维护应用的核心需求。而 <code>record</code> 正是C# 9.0引入的一项革命性语言特性，专为“数据承载”场景而生。它不仅大幅减少了样板代码，更通过<strong>值语义相等性</strong>和<code>with</code>表达式，让数据操作更加安全、直观[citation:1]。</p><p>与传统的 <code>class</code> 不同，<code>record</code> 强调“这个对象是什么”，而非“它能做什么”。本文将通过真实示例，深入剖析 <code>record</code> 的工作原理、常见陷阱与最佳实践。</p><h2>一个典型的record使用场景</h2><p>以下是一个天气预报数据模型，使用 <code>record</code> 简化定义：</p><pre><code>public record WeatherForecast(\n    DateOnly Date,\n    int TemperatureC,\n    string? Summary)\n{\n    public int TemperatureF => 32 + (int)(TemperatureC * 1.8);\n}</code></pre><p>在这个例子中，我们仅用一行声明就完成了属性定义、构造函数生成和不可变性设置。任何尝试修改字段的行为都必须通过 <code>with</code> 表达式创建新实例，从而避免了状态污染。这在Web API返回DTO时极为高效。</p><h2>record vs class：核心区别</h2><p>虽然两者都能定义类型，但它们的设计哲学和行为机制截然不同。</p><table border=\"1\" cellpadding=\"8\" style=\"border-collapse: collapse; width: 100%; margin: 1rem 0;\">\n  <tr style=\"background-color: #f5f5f5;\">\n    <th>特性</th>\n    <th><code>class</code></th>\n    <th><code>record</code></th>\n  </tr>\n  <tr>\n    <td><strong>默认可变性</strong></td>\n    <td>可变（<code>set</code>）</td>\n    <td>不可变（<code>init</code>）</td>\n  </tr>\n  <tr>\n    <td><strong>相等性比较</strong></td>\n    <td>引用相等（地址）</td>\n    <td>值相等（字段内容）</td>\n  </tr>\n  <tr>\n    <td><strong><code>ToString()</code> 输出</strong></td>\n    <td>类型名称（如 <code>WeatherForecast</code>）</td>\n    <td>格式化字段值（如 <code>WeatherForecast { Date = 10/31/2025, TemperatureC = 25 }</code>）</td>\n  </tr>\n  <tr>\n    <td><strong>复制与修改</strong></td>\n    <td>需手动实现克隆逻辑</td>\n    <td>支持 <code>with</code> 表达式进行非破坏性修改</td>\n  </tr>\n  <tr>\n    <td><strong>继承与相等性</strong></td>\n    <td>默认不跨类型相等</td>\n    <td>子类包含父类字段参与比较</td>\n  </tr>\n</table><h2>record的两种形式</h2><h3>1. 位置记录（Positional Record）</h3><pre><code>public record Person(string Name, int Age);</code></pre><p>使用主构造函数参数，编译器自动生成同名 <code>get; init;</code> 属性，并自动实现 <code>Equals</code>、<code>GetHashCode</code> 和 <code>ToString</code>，极大简化数据类定义。</p><h3>2. 经典记录（Classic Record）</h3><pre><code>public record Point\n{\n    public int X { get; init; }\n    public int Y { get; init; }\n}</code></pre><p>语法类似于普通类，但依然享有 <code>record</code> 的所有语义优势，适合需要额外方法或复杂逻辑的场景。</p><h2>重要特性：with表达式与不可变性</h2><p><code>record</code> 的最大优势之一是支持 <code>with</code> 表达式，实现“非破坏性修改”——即创建一个新实例，仅修改指定字段。</p><pre><code>var forecast1 = new WeatherForecast(DateOnly.FromDateTime(DateTime.Today), 25, \"Sunny\");\nvar forecast2 = forecast1 with { TemperatureC = 30 };\n\nConsole.WriteLine(forecast1.TemperatureC); // 输出: 25\nConsole.WriteLine(forecast2.TemperatureC); // 输出: 30\nConsole.WriteLine(forecast1 == forecast2); // ✅ False（值不同）</code></pre><p>这在函数式编程、配置更新、事件溯源或API版本兼容中极为有用，确保原始数据不被污染。</p><h2>继承与record</h2><p><code>record</code> 支持继承，且会正确处理相等性比较：</p><pre><code>public record Employee(string Name, int Age, string EmployeeId) : Person(Name, Age);</code></pre><p>子类会包含父类的所有属性，并参与相等性判断。注意：两个不同类型的 <code>record</code> 即使字段相同，也不相等，这增强了类型安全性。</p><h2>常见陷阱与注意事项</h2><h3>1. record是引用类型</h3><p>尽管行为像值对象，但 <code>record</code> 默认仍是引用类型（在堆上分配）。若需值类型语义并控制内存布局，可使用 <code>record struct</code>（C# 10+）：</p><pre><code>public record struct Point3D(int X, int Y, int Z);</code></pre><h3>2. 可空引用类型兼容性</h3><p>在启用可空上下文时，记得使用 <code>string?</code> 显式标记可空字段，避免误用：</p><pre><code>public record User(string Name, string? Email);</code></pre><p>这有助于编译器提前发现潜在的 null 引用异常。</p><h3>3. 避免过度嵌套with表达式</h3><p>虽然 <code>with</code> 很强大，但链式调用过多可能导致性能下降或内存压力：</p><pre><code>var updated = original with { A = 1 } with { B = 2 } with { C = 3 }; // 创建3个临时实例</code></pre><p>高频场景建议评估是否改用可变类或结构体。</p><h2>静态与嵌套record</h2><p>虽然 <code>record</code> 本身不能是静态的，但你可以将其定义为静态类的嵌套类型，用于组织DTO：</p><pre><code>public static class ApiContracts\n{\n    public record LoginRequest(string Username, string Password);\n    public record OrderResponse(Guid Id, decimal Total, string Status);\n}</code></pre><p>这种方式既保持命名空间整洁，又体现语义分组。</p><h2>最佳实践</h2><h3>1. 优先用于DTO和消息</h3><p>在Web API、微服务通信、领域事件、CQRS命令/查询中，<code>record</code> 是定义数据结构的首选，因其简洁、安全、语义清晰。</p><h3>2. 避免频繁修改的实体</h3><p>若对象需要频繁更新多个字段，每次 <code>with</code> 都会创建新实例，可能影响性能。此时传统 <code>class</code> 或 <code>struct</code> 更合适。</p><h3>3. 结合init-only属性提升封装性</h3><p>即使不使用位置语法，也可在普通类中使用 <code>init</code> 属性实现部分不可变性：</p><pre><code>public class Order\n{\n    public Guid Id { get; init; }\n    public decimal Total { get; set; } // 可变\n    public DateTime CreatedAt { get; init; }\n}</code></pre><p>这在EF Core等ORM中非常实用，确保ID和创建时间不可更改。</p><h2>结语：record是现代C#的基石</h2><p><code>record</code> 不仅是一种语法糖，更代表了C#向<strong>函数式与面向对象融合</strong>的演进。它通过减少样板代码、强化不可变性、提供值语义，显著提升了开发效率与代码质量。</p><p>在数据建模、配置传递、消息定义等场景中，合理使用 <code>record</code> 能有效防止状态错误，让团队协作更加顺畅。</p><p>记住：<strong>当你定义的是‘数据’而非‘行为’时，首选 <code>record</code></strong>。让语言特性帮你写出更优雅、更安全的C#代码。</p>"
	}
]